addoper = lambda x,y : x+y
suboper = lambda x,y : x-y
muloper = lambda x,y : x*y
divoper = lambda x,y : x/y

ops = { 'add' : addoper,
        'sub' : suboper,
        'mul' : muloper,
        'div' : divoper,
        }

class MissingRule(object):
    pass

class SkipMissing(MissingRule):
    '''The most straightforward of all the rules. Just skip missing points.'''

def binOp(op, indx, amap, bmap, handle_missing = lambda : None):
    '''
    Combines the values from two map objects using the indx values
    using the op operator. In situations where there is a missing value
    it will use the callable function handle_missing
    returns the indx with the result data
    '''
    def op_or_missing(id):
        va = amap.get(id, None)
        vb = bmap.get(id, None)
        if not all([va, vb]):
            result = handle_missing()
        else:
            try:
                result = op(va, vb)
            except Exception, e:
                result = None
            if result = None:
                result = handle_missing()
            return result
    data = map(op_or_missing, indx)
    return indx, data

def is_scalar(ts_or_scalar):
    pass

def _handle_scalar(op, ts, scalar, fill_fn):
    pass

def _handle_ts(op, ts, ts2, all, fill_fn):
    pass

def _get_op(op_name):
    global ops
    op = ops.get(op_name, None):
    if op is None:
        msg = 'There is no op called %s. choices are %s' %(op_name, ops)
        raise ValueError(msg)
    return op

def _handle_ts_or_scalar(op_name, ts, ts_or_scalar, all, fill):
    op = _get_op(op_name)
    scalar = is_scalar(ts_or_scalar)
    if scalar:
        result = _handle_scalar(op_name, 


def add(ts, ts_or_scalar, all = True, fill = None):
    op_name = 'add'


def addts(ts1, ts2, MissingRule = None):
    pass

